

---

## Завдання 1
#### Основні зміни

| Елемент | Початковий код | Перероблений код |
|--------|----------------|------------------|
| **Базовий клас** | Відсутній | Додано абстрактний клас `Vehicle` з методом `start_engine()` |
| **Наслідування** | `Car` і `Motorcycle` — окремі класи | Обидва наслідують `Vehicle` |
| **Створення об'єктів** | Пряме створення: `Car(...)`, `Motorcycle(...)` | Через фабрики: `factory.create_car(...)` |
| **Регіональні специфікації** | Відсутні | Додано мітки `(US Spec)` або `(EU Spec)` |
| **Фабрика** | Відсутня | Додано абстрактний клас `VehicleFactory` і реалізації `USVehicleFactory`, `EUVehicleFactory` |
| **Типізація** | Не використовується | Додано типи: `str`, `-> None`, `-> Vehicle` |
| **Логування** | `print()` | Заміна на `logging.info()` |
| **Форматування** | Не згадується | Очікується використання `black` |



Ось табличка, яка узагальнює зміни, внесені до програми бібліотеки згідно з принципами SOLID:

---

###  Завдання 2
#### Основні зміни

| Принцип SOLID | Що означає | Зміни в коді | Клас / Компонент |
|---------------|------------|--------------|------------------|
| **SRP** (Single Responsibility) | Кожен клас має одну відповідальність | Створено окремий клас `Book` для зберігання даних про книгу | `Book` |
| **OCP** (Open/Closed) | Клас відкритий для розширення, але закритий для модифікації | Реалізація через інтерфейс дозволяє додавати нові типи бібліотек | `Library`, `LibraryInterface` |
| **LSP** (Liskov Substitution) | Підкласи можуть замінити базовий клас без порушення логіки | `Library` реалізує `LibraryInterface`, тому може бути замінений | `Library` |
| **ISP** (Interface Segregation) | Інтерфейси мають бути вузькими і специфічними | Створено інтерфейс `LibraryInterface` з чітко визначеними методами | `LibraryInterface` |
| **DIP** (Dependency Inversion) | Вищі рівні не залежать від реалізацій, а від абстракцій | `LibraryManager` працює з інтерфейсом, а не з конкретним класом | `LibraryManager` |

